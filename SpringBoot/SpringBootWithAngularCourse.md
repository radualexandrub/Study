Credits / Notes taken from:

- [Spring Boot Full Stack with Angular Application - Full Course 05-Feb-2021 - Amigoscode - 2h40m](https://youtu.be/Gx4iBLKLVHk)

<br/>

Table of Contents



<br/>

Prerequisites:

- [Java](https://www.java.com/en/). Check out my [Study Notes on Java](https://github.com/radualexandrub/Study/blob/master/Java/README.md).
- [Apache Maven (mvn)](https://maven.apache.org/download.cgi).
- [Node.js installed](https://nodejs.org/en/). We need it to use NPM (Node Package Manager) to create an Angular App.
- [Angular](https://angular.io/). Check out my [Study Notes on Angular](https://github.com/radualexandrub/Study/blob/master/Angular/README.md).
- [IntelliJ IDEA (Community or other)](https://www.jetbrains.com/idea/) or [Eclipse IDE](https://www.eclipse.org/ide/).
- [Visual Studio Code](https://code.visualstudio.com/).
- [Postman API Platform](https://www.postman.com/) and [HTTPie ‚Äì API testing client](https://httpie.io/)... or you can use [Insomnia](https://insomnia.rest/) instead
- [MySQL 8.0 (448MB installer)](https://dev.mysql.com/downloads/installer/)

<br/>

# Back-End

## Project Setup


### Installing Maven

(Sunday, August 14, 2022)

Note that we need to have [Apache Maven](https://maven.apache.org/download.cgi) installed on our machine.

You can download the "Binary zip archive". Then follow the install notes from Maven `README.txt` file:

```
  Installing Maven
  ----------------

  1) Unpack the archive where you would like to store the binaries, e.g.:

    Unix-based operating systems (Linux, Solaris and Mac OS X)
      tar zxvf apache-maven-3.x.y.tar.gz
    Windows
      unzip apache-maven-3.x.y.zip

  2) A directory called "apache-maven-3.x.y" will be created.

  3) Add the bin directory to your PATH, e.g.:

    Unix-based operating systems (Linux, Solaris and Mac OS X)
      export PATH=/usr/local/apache-maven-3.x.y/bin:$PATH
    Windows
      set PATH="c:\program files\apache-maven-3.x.y\bin";%PATH%

  4) Make sure JAVA_HOME is set to the location of your JDK

  5) Run "mvn --version" to verify that it is correctly installed.
```

![SpringInitializr](./SpringBootWithAngularCourse/SpringInitializr04.jpg)

![SpringInitializr](./SpringBootWithAngularCourse/SpringInitializr05.jpg)

<br/>


### Initialize project with Spring Initializr

[Spring Initializr - Initializr generates spring boot project with just what you need to start quickly!](https://start.spring.io)

Project configuration:

- *Project:* Maven Project
- *Spring Boot:* Version 2.7.2
- *Project Metadata:*
    - *Group (domain):* "ENTER YOUR DOMAIN HERE" (for me it'll be [com.radubulai](https://radubulai.com))
    - *Artifact (the name of the application):* employeemanager
    - *Name:* employeemanager
    - *Description:* Employee Manager App
    - *Package name (you could leave the autogenerated name):* com.radubulai.employeemanager
    - *Packaging:* Jar
    - *Java Version:* 8

Dependencies:

- Spring Web
- Spring Data JPA
- MySQL Driver

![SpringInitializr](./SpringBootWithAngularCourse/SpringInitializr01.jpg)

We can click "Explore" button to look at our Project's `pom.xml` file.

> From https://maven.apache.org/guides/introduction/introduction-to-the-pom.html:

> A Project Object Model or POM is the fundamental unit of work in Maven. It is an XML file that contains information about the project and configuration details used by Maven to build the project. It contains default values for most projects. Examples for this is the build directory, which is `target`; the source directory, which is `src/main/java`; the test source directory, which is `src/test/java`; and so on. When executing a task or goal, Maven looks for the POM in the current directory. It reads the POM, gets the needed configuration information, then executes the goal.

> Some of the configuration that can be specified in the POM are the project dependencies, the plugins or goals that can be executed, the build profiles, and so on. Other information such as the project version, description, developers, mailing lists and such can also be specified.

The contents of `pom.xml` file that will be generated:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>2.7.2</version>
    <relativePath/> <!-- lookup parent from repository -->
  </parent>
  <groupId>com.radubulai</groupId>
  <artifactId>employeemanager</artifactId>
  <version>0.0.1-SNAPSHOT</version>
  <name>employeemanager</name>
  <description>Employee Manager App</description>
  <properties>
    <java.version>1.8</java.version>
  </properties>
  <dependencies>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <dependency>
      <groupId>mysql</groupId>
      <artifactId>mysql-connector-java</artifactId>
      <scope>runtime</scope>
    </dependency>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-test</artifactId>
      <scope>test</scope>
    </dependency>
  </dependencies>

  <build>
    <plugins>
      <plugin>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-maven-plugin</artifactId>
      </plugin>
    </plugins>
  </build>

</project>
```

Finally, we can click on "GENERATE" button to generate our Spring project! And we can extract the `employeemanager.zip` archive into a `employeemanager` folder.

We can open our project in IntelliJ IDEA by opening the `pom.xml` file -> "Open as Project".

![SpringInitializr](./SpringBootWithAngularCourse/SpringInitializr02.jpg)

And we should see our main java file of our application:

![SpringInitializr](./SpringBootWithAngularCourse/SpringInitializr-main-file.jpg)

<br/>

---

<br/>

(Optional) Useful links/settings on IntelliJ IDEA:

- https://stackoverflow.com/questions/2065659/how-to-increase-the-maximum-number-of-opened-editors-in-intellij (default maximum number of open tabs is 10...)

![SpringInitializr](./SpringBootWithAngularCourse/SpringInitializr03.jpg)

<br/>

## Create Employee model class

To create a first model class, we right click on our main project package -> New -> Package -> "model".

Inside our "model" package, we right click -> New -> New Java Class -> "Employee".

![SpringInitializr](./SpringBootWithAngularCourse/ModelClass01.jpg)

Our employee model will have the following fields:

```java
// Employee.java
package com.radubulai.employeemanager.model;

import java.io.Serializable;

public class Employee implements Serializable {
    private Long id;
    private String name;
    private String email;
    private String jobTitle;
    private String phone;
    private String imageUrl;
    private String employeeCode;
}
```

We will also have our class been implemented from the `Serializable` interface (our class "inherits" the `Serializable` class) in order to be able to "transform" this Java "Employee" Class into different types of strings (because this class will be saved in a database, and it should be able for this class to be converted in something like e.g. JSON). So it's always a good practice to make model classes being implemented as `Serializable`.

<br/>

Now we want this class to be in a database - that's why we added [*"Spring Data JPA (Java Persistence API)"*](https://spring.io/projects/spring-data-jpa):
- We first add the `@Entity` decorator
- We need to set our "PRIMARY KEY", for this we add `@Id` decorator. We also need to tell it how to generate this ID, so we add `@GeneratedValue(strategy = GenerationType.IDENTITY)` (with the passed parameter of `strategy`)
- We can also set different SQL "parameters" for our Id column, like "NOT NULL", "NOT UPDATABLE", etc, by using more decorators such as `@Column(nullable = false, updatable = false)`.

```java
// Employee.java
package com.radubulai.employeemanager.model;

import javax.persistence.*;
import java.io.Serializable;

@Entity
public class Employee implements Serializable {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(nullable = false, updatable = false)
    private Long id;
    private String name;
    private String email;
    private String jobTitle;
    private String phone;
    private String imageUrl;
    @Column(nullable = false, updatable = false)
    private String employeeCode;
}
```

![SpringInitializr](./SpringBootWithAngularCourse/ModelClass02.jpg)

<br/>

Now, in this same file `Employee.java`, we will generate all the constructors and getters and setters. Note that we can use IntelliJ's IDEA "Generate..." menu for automatic generation of these methods: (instead of writing them manually). Right click on `public class Employee implements Serializable`:
- Generate... -> Constructor (select all fields/properties)
- Generate... -> Getter and Setter
- Generate... -> toString()

All the code for `src/main/java/com/radubulai/employeemanager/model/Employee.java`:

```java
// Employee.java
package com.radubulai.employeemanager.model;

import javax.persistence.*;
import java.io.Serializable;

@Entity
public class Employee implements Serializable {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(nullable = false, updatable = false)
    private Long id;
    private String name;
    private String email;
    private String jobTitle;
    private String phone;
    private String imageUrl;
    @Column(nullable = false, updatable = false)
    private String employeeCode;

    public Employee() {}

    public Employee(Long id, String name, String email, String jobTitle, String phone, String imageUrl, String employeeCode) {
        this.id = id;
        this.name = name;
        this.email = email;
        this.jobTitle = jobTitle;
        this.phone = phone;
        this.imageUrl = imageUrl;
        this.employeeCode = employeeCode;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getJobTitle() {
        return jobTitle;
    }

    public void setJobTitle(String jobTitle) {
        this.jobTitle = jobTitle;
    }

    public String getPhone() {
        return phone;
    }

    public void setPhone(String phone) {
        this.phone = phone;
    }

    public String getImageUrl() {
        return imageUrl;
    }

    public void setImageUrl(String imageUrl) {
        this.imageUrl = imageUrl;
    }

    public String getEmployeeCode() {
        return employeeCode;
    }

    public void setEmployeeCode(String employeeCode) {
        this.employeeCode = employeeCode;
    }

    @Override
    public String toString() {
        return "Employee{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", email='" + email + '\'' +
                ", jobTitle='" + jobTitle + '\'' +
                ", phone='" + phone + '\'' +
                ", imageUrl='" + imageUrl + '\'' +
                ", employeeCode='" + employeeCode + '\'' +
                '}';
    }
}
```

<br/>

## Database Configuration

[Spring Boot Full Stack with Angular - Amigoscode - 0h20m](https://youtu.be/Gx4iBLKLVHk?t=1202)

After installing [MySQL 8.0 (448MB installer)](https://dev.mysql.com/downloads/installer/), we can open "MySQL 8.0 Command Line Client" (from Windows Start Menu), and type commands like `show databases;`.

![](./SpringBootWithAngularCourse/ConfigureDatabase01.jpg)

<br/>

To set up our database in our Java Spring Application, we need to go to `src/main/resource/application.properties`:

- the default port for MySQL is 3306, so the DB address will be `localhost:3306`
- the name of the database will be `employeemanager` => the address will be `localhost:3306/employeemanager`
- the username and the password (Note that we would normally have the password stored on a remote server, or on a different file on our system, or as Environment Variables in our system... and preferably encrypted...)
- `spring.jpa.show-sql=true` will show the SQL queries in the console whenever the JPA (our Java app) is executing an SQL query
- `spring.jpa.hibernate.ddl-auto` specifies the data description language - will tell the application how to manage the database
  - if it's set to `create`, every time we run the application it will drop all the tables and it will create them again
  - if set to `update`, every time we run the app it is going to update all the tables if necesary
- `spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5Dialect`

<br/>

`application.properties`:

```
# MySQL Configuration
spring.datasource.url=jdbc:mysql://localhost:3306/employeemanager
spring.datasource.username=root
spring.datasource.password=yourpassword
spring.jpa.show-sql=true
spring.jpa.hibernate.ddl-auto=update
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5Dialect
```

<br/>

Let's now create the `employeemanager` database in MySQL:

- Open "MySQL 8.0 Command Line Client", write: `create database employeemanager;`
- We can check with `show databases;` command

<br/>

We can run our java application by clicking on "Run Application" on our main java function (in `EmployeemanagerApplication.java`):

```
  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::                (v2.7.2)

2022-08-14 21:09:58.036  INFO 8364 --- [           main] c.r.e.EmployeemanagerApplication         : Starting EmployeemanagerApplication using Java 17.0.1 on radu-legion with PID 8364 (E:\Proiecte SSD\SpringBoot\employeemanager\target\classes started by radu in E:\Proiecte SSD\SpringBoot\employeemanager)
```

![](./SpringBootWithAngularCourse/ConfigureDatabase02.jpg)

<br/>

üü¢ Note: we can also run the Java Application from Terminal, in the main project directory:

```bash
# E:\Proiecte SSD\SpringBoot\employeemanager>
mvn spring-boot:run
```

üü¢ Also note, that after running the app, the `Employee` table from the `employeemanager` database is created automatically in MySQL and can be seen via MySQL Workbench App:

- On MySQL Workbench -> Click on "Database" from the menu -> "Reverse Engineer(CTRL+B)" -> next, next, next -> Select your schema -> "execute".

![](./SpringBootWithAngularCourse/ConfigureDatabase03.jpg)

![](./SpringBootWithAngularCourse/ConfigureDatabase04.jpg)

![](./SpringBootWithAngularCourse/ConfigureDatabase05.jpg)

<br/>

## Java CRUD Operations in Database - Service

[Spring Boot Full Stack with Angular - Amigoscode - 0h26m: Employee Repository](https://youtu.be/Gx4iBLKLVHk?t=1561)

All these operations will be created under a "Employee Repository" Java package (with the name of `repo` package) and a `service` package as controller.

<br/>

### Inheriting JPA Repository

For the `repo` package:

- On our main project package -> create a new package called `repo`
- Inside `repo` package, we create a **Java Interface** called `EmployeeRepo`
- This interface `EmployeeRepo` will extend the `JpaRepository`. Also, when extending from `JpaRepository` interface, we need to specify the model type (`Employee`) and the ID data type (`Long`): `public interface EmployeeRepo extends JpaRepository<Employee, Long>`.

> (Note: To inherit from a class, the `extends` keyword is used, eg. we could have an `Animal`/`User` class, and `Dog`/`Author` extends that class - inherits all the properties from `Animal`/`User` main class)

- We can CTRL+Click on `JpaRepository` interface to see its decompilled .class file (its code), and look over its methods, eg: findAll, saveAll, deleteAllInBatch, etc... (those are useful methods as we don't need to implement them from scratch)

```java
// ../repo/EmployeeRepo.java
package com.radubulai.employeemanager.repo;

import com.radubulai.employeemanager.model.Employee;
import org.springframework.data.jpa.repository.JpaRepository;

public interface EmployeeRepo extends JpaRepository<Employee, Long> {

}
```

<br/>

### Employee Service

For the `service` package that we are going to use for our "Controller":

- On our main/base project package -> create a new package called `service`
- Inside `service` package, create a new **Java Class** called `EmployeeService`
- Here in `EmployeeService` we create a `EmployeeRepo` object, and we can also override the constructor
- We also need to annotate the `EmployeeService` class repo with `@Service` decorator

> From https://www.digitalocean.com/community/tutorials/spring-service-annotation
> Spring @Service annotation is used with classes that provide some business functionalities. Spring context will autodetect these classes when annotation-based configuration and classpath scanning is used.

- And, on constructor, we also need to add `@Autowired` decorator so we can bring its dependencies

> From https://www.baeldung.com/spring-autowire
> Starting with Spring 2.5, the framework introduced annotations-driven Dependency Injection. The main annotation of this feature is @Autowired. **It allows Spring to resolve and inject collaborating beans into our bean.**

> The Spring framework enables automatic dependency injection. In other words, by declaring all the bean dependencies in a Spring configuration file, Spring container can autowire relationships between collaborating beans. This is called Spring bean autowiring.

```java
// ../service/EmployeeService.java
package com.radubulai.employeemanager.service;

import com.radubulai.employeemanager.repo.EmployeeRepo;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class EmployeeService {
    private final EmployeeRepo employeeRepo;

    @Autowired
    public EmployeeService(EmployeeRepo employeeRepo) {
        this.employeeRepo = employeeRepo;
    }
}

```

![](./SpringBootWithAngularCourse/JavaCRUD01.jpg)

<br/>

And now, we can define all our CRUD operations within this `EmployeeService` class:

1. **addEmployee**

- `addEmployee` method will return an `Employee` object (from the model package we created earlier), and will accept as a parameter an `Employee` object.
- the `id` will be generated/incremented automatically in our database
- we generate an employee code (for the `employeeCode` column) - for this we can use the Java builtin `UUID` class (a 128bit immutable universally unique identifier - UUID): `UUID.randomUUID().toString()`
- we return the returned `Employee` object from calling the JPA Repository `save` method: `return employeeRepo.save(employee);`

```java
// ../service/EmployeeService.java
public Employee addEmployee(Employee employee) {
    employee.setEmployeeCode(UUID.randomUUID().toString());
    return employeeRepo.save(employee);
}
```

[Spring Boot Full Stack with Angular - Amigoscode - 0h31m: Service class](https://youtu.be/Gx4iBLKLVHk?t=1902)

<br/>

2. **findAllEmployees** - Return (View) the list of all employees

- `findAllEmployees` will not take any parameters
- we just return the returned value from calling the JPA Repository method `return employeeRepo.findAll();`

```java
// ../service/EmployeeService.java
public List<Employee> findAllEmployees() {
    return employeeRepo.findAll();
}
```

<br/>

3. **updateEmployee**

```java
// ../service/EmployeeService.java
public Employee updateEmployee(Employee employee) {
    return employeeRepo.save(employee);
}
```


<br/>

4. **deleteEmployee**

- since we can't use `employeeRepo.delete(id);` because the `delete` method from inherited JPA Repo does not accept any `Long` type parameter (as an ID), we will need to create our own `employeeRepo.deleteEmployeeById(id);` inside `/repo/EmployeeRepo.java`
- Spring is smart enough to automatically create queries just by having the method named as `deleteObjecttypeById` üëç. More on this here: https://www.baeldung.com/spring-data-derived-queries

```java
// ../service/EmployeeService.java
public void deleteEmployee(Long id) {
    employeeRepo.deleteEmployeeById(id);
}
```

```java
// ../repo/EmployeeRepo.java
public interface EmployeeRepo extends JpaRepository<Employee, Long> {
    void deleteEmployeeById(Long id);
}
```

<br/>

4. **findEmployeeById** - Find/Return an employee by Id

- findEmployeeById does not exist, but just by calling this method as `findObjectById` (declared within `repo/EmployeeRepo.java`), Spring will automatically define this method as a Query to our database (eg. MySQL) üëç. In this case, the query (based on the method name), will be something like `SELECT Employee BY Id WHERE Id = ProvidedId`. More on this here: https://www.baeldung.com/spring-data-derived-queries

```java
// ../service/EmployeeService.java
public Employee findEmployeeById(Long id) {
    return employeeRepo.findEmployeeById(id);
}
```

- but, we will be having a problem: if there is no Employee in the database with the provided id, we shoul not return anything. For this, we change in /repo/EmployeeRepo the method declaration from `Employee findEmployeeById(Long id);` to `Optional findEmployeeById(Long id);` (`import java.util.Optional;`).
- then, in /service/EmployeeService, we can use some Java 8 methods, like `orElseThrow` - namely, if we find an Employee by the provided Id as parameter, we return that Employee, else, we throw some exception (using Java 8 Lambda functions)

```java
public interface EmployeeRepo extends JpaRepository<Employee, Long> {
    void deleteEmployeeById(Long id);
    Optional<Employee> findEmployeeById(Long id);
}

```

```java
// ../service/EmployeeService.java
public Employee findEmployeeById(Long id) {
    return employeeRepo.findEmployeeById(id).orElseThrow(
            () -> new UserNotFoundException("User by id " + id + " was not found")
    );
}
```

Handling Exceptions:

- but now, we need to create that `UserNotFoundException`... for this, we will create an `exception` package in our main app package and create a `UserNotFoundException` class inside it (Note that creation of `exception` package and `UserNotFoundException` class inside it could be done automatically by IntelliJ IDEA -> Just hover over the error -> "More actions..." -> "Create Class UserNotFoundException" -> change the name for "Destion Package" from "service" to "exception", IntelliJ IDEA will create `exception` automatically for you).
- here in `/exception/UserNotFoundException.java`, we will just inherit from `RuntimeException` class and we'll call its constructor with `super` method, that will just pass the message that we gave earlier as parameter (`"User by id " + id + " was not found"`):

```java
// ../exception/UserNotFoundException
public class UserNotFoundException extends RuntimeException {
    public UserNotFoundException(String message) {
        super(message);
    }
}
```

<br/>
<br/>

Finally, these were all the methods for the `EmployeeService.java`:

```java
// Complete code for ../service/EmployeeService.java
package com.radubulai.employeemanager.service;

import com.radubulai.employeemanager.exception.UserNotFoundException;
import com.radubulai.employeemanager.model.Employee;
import com.radubulai.employeemanager.repo.EmployeeRepo;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.UUID;

@Service
public class EmployeeService {
    private final EmployeeRepo employeeRepo;

    @Autowired
    public EmployeeService(EmployeeRepo employeeRepo) {
        this.employeeRepo = employeeRepo;
    }

    public Employee addEmployee(Employee employee) {
        employee.setEmployeeCode(UUID.randomUUID().toString());
        return employeeRepo.save(employee);
    }

    public List<Employee> findAllEmployees() {
        return employeeRepo.findAll();
    }

    public Employee updateEmployee(Employee employee) {
        return employeeRepo.save(employee);
    }

    public void deleteEmployee(Long id) {
        employeeRepo.deleteEmployeeById(id);
    }

    public Employee findEmployeeById(Long id) {
        return employeeRepo.findEmployeeById(id).orElseThrow(
                () -> new UserNotFoundException("User by id " + id + " was not found")
        );
    }
}
```

```java
// Complete code for ../repo/EmployeeRepo.java
package com.radubulai.employeemanager.repo;

import com.radubulai.employeemanager.model.Employee;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface EmployeeRepo extends JpaRepository<Employee, Long> {

    void deleteEmployeeById(Long id);

    Optional<Employee> findEmployeeById(Long id);
}
```

![](./SpringBootWithAngularCourse/JavaCRUD02.jpg)



<br/>

## Exposing the API - Controller

(Monday, August 15, 2022)

[Spring Boot Full Stack with Angular - Amigoscode - 0h39m: Exposing the API](https://youtu.be/Gx4iBLKLVHk?t=2335)

![](./SpringBootWithAngularCourse/ExposingAPI01.jpg)

![](./SpringBootWithAngularCourse/ExposingAPI02.jpg)

<br/>

Let's create our controller class:

- in the main app package, create a new **Java Class** named "EmployeeResource" (this will be our controller).
- just before the declaration of `EmployeeResource` class, we will add a `@RestController` decorator/annotation
- just before the declaration of `EmployeeResource` class, we will also add `@RequestMapping("/employee")` annotation, where `/employee` would be our REST API route/URL to all employees entries from our database
- inside `EmployeeResource` class, we will bring the service class (`EmployeeService`) that we created earlier (that has our CRUD operations), and we also inject this service into `EmployeeResource`'s constructor so we can autowire the service inside that class: `public EmployeeResource(EmployeeService employeeService)`.

```java
// EmployeeResource.java
@RestController
@RequestMapping("/employee")
public class EmployeeResource {
    private final EmployeeService employeeService;

    public EmployeeResource(EmployeeService employeeService) {
        this.employeeService = employeeService;
    }
}
```

> From https://www.baeldung.com/spring-controller-vs-restcontroller
> Spring 4.0 introduced the `@RestController` annotation in order to simplify the creation of RESTful web services. **It's a convenient annotation that combines `@Controller` and `@ResponseBody`**, which eliminates the need to annotate every request handling method of the controller class with the @ResponseBody annotation.

> We can annotate classic controllers with the `@Controller` annotation. This is simply a specialization of the `@Component` class, **which allows us to auto-detect implementation classes through the classpath scanning**.

> We typically use `@Controller` in combination with a @RequestMapping annotation for request handling methods.

<br/>

1. **getAllEmployees** (GET HTTP Request)

Now, let's create our first (exposed) method (as a REST API) that returns all of our employees from the database:

- we will need to add to this method the `@GetMapping` decorator to tell Spring that this is a `GET` type of request. We can also include a path for this request, like `@GetMapping("/all")`
- `getAllEmployees` method will return an HTTP response, for this we will use `ResponseEntity` generic class from Spring -> for this generic class we will specify as a type a List of Employee objects: `ResponseEntity<List<Employee>>`: so we'll have `public ResponseEntity<List<Employee>> getAllEmployees()`
- now we need to call the `findAllEmployees` method from our `EmployeeServices` that will return all the employees from our database: `List<Employee> employees = employeeService.findAllEmployees();`
- as return for this method, we will `return new ResponseEntity<>(employees, HttpStatus.OK);`, that has all the `employees` inside (list of employees), and the HTTP status code of success

```java
// EmployeeResource.java
@RestController
@RequestMapping("/employee")
public class EmployeeResource {
    private final EmployeeService employeeService;

    public EmployeeResource(EmployeeService employeeService) {
        this.employeeService = employeeService;
    }

    @GetMapping("/all")
    public ResponseEntity<List<Employee>> getAllEmployees() {
        List<Employee> employees = employeeService.findAllEmployees();
        return new ResponseEntity<>(employees, HttpStatus.OK);
    }
}
```

<br/>

2. **getEmployeeById** (GET HTTP Request)

This method will return/find only one user/employee based on provided Id:

- we will need to add to this method the `@GetMapping("/find/{id}")` decorator to tell Spring that this is a `GET` type of request, and the path/URL for this request will be `/employee/find/{id}`
- we will pass this `{id}` from the decorator (that will be provided in the URL/PATH of the request) as a parameter to this method by using `@PathVariable("id")` Spring Annotation => now we have access to the id that was passed into the URL.

![](./SpringBootWithAngularCourse/ExposingAPI03.jpg)

- now we call the `findAllEmployeeById` method from our `EmployeeServices`: `Employee employee = employeeService.findEmployeeById(id);`
- and we `return new ResponseEntity<>(employee, HttpStatus.OK);`

```java
// EmployeeResource.java
@GetMapping("/find/{id}")
public ResponseEntity<Employee> getEmployeeById(@PathVariable("id") Long id) {
    Employee employee = employeeService.findEmployeeById(id);
    return new ResponseEntity<>(employee, HttpStatus.OK);
}
```

<br/>

3. **addEmployee** (POST HTTP Request)

This method will add/create a new employee:

- we will need to add to this method the `@PostMapping("/add")` decorator to tell Spring that this is a `POST` type of HTTP request, and the path/URL for this request will be `/employee/add`
- this `addEmployee` method will return the newly created `Employee` object as a response
- this `addEmployee` method will take as a parameter a whole `Employee` object (with all the required details such as email, image_url, job_title, name, phone) that'll as a JSON format
  - for this, we can use `@RequestBody` Spring annotation: `public ResponseEntity<Employee> addEmployee(@RequestBody Employee employee)`
- we will call the `addEmployee` method from our `EmployeeServices`: `Employee newEmployee = employeeService.addEmployee(employee);`
- we will `return new ResponseEntity<>(newEmployee, HttpStatus.CREATED);`, where `HttpStatus.CREATED` means that we created a new information on the server

```java
// EmployeeResource.java
@PostMapping("/add")
public ResponseEntity<Employee> addEmployee(@RequestBody Employee employee) {
    Employee newEmployee = employeeService.addEmployee(employee);
    return new ResponseEntity<>(newEmployee, HttpStatus.CREATED);
}
```

<br/>

4. **updateEmployee** (PUT HTTP Request)

This method will update an existing employee:

- we will need to add to this method the `@PutMapping("/update")` decorator to tell Spring that this is a `PUT` type of HTTP request, and the path/URL for this request will be `/employee/update`
- this `updateEmployee` method will return the updated `Employee` object as a response
- this `addEmployee` method will take as a parameter a whole `Employee` object (with all the required details such as email, image_url, job_title, name, phone) that'll as a JSON format: `public ResponseEntity<Employee> updateEmployee(@RequestBody Employee employee)`
- we will call the `updateEmployee` method from our `EmployeeServices`: `Employee updatedEmployee = employeeService.updateEmployee(employee);`
- we will `return new ResponseEntity<>(updatedEmployee, HttpStatus.OK);`

```java
// EmployeeResource.java
@PutMapping("/update")
public ResponseEntity<Employee> updateEmployee(@RequestBody Employee employee) {
    Employee updatedEmployee = employeeService.updateEmployee(employee);
    return new ResponseEntity<>(updatedEmployee, HttpStatus.OK);
}
```

<br/>

5. **deleteEmployee** (GET HTTP Request)

This method will delete an employee from database based on provided Id through request URL/Path:

- we will need to add to this method the `@DeleteMapping("/delete/{id}")` decorator to tell Spring that this is a `DELETE` type of HTTP request, and the path/URL for this request will be `/employee/delete/{id}`
- this `deleteEmployee` method will only return the HTTP Request status: `public ResponseEntity<?> deleteEmployee(@PathVariable("id") Long id)` (we pass a question mark `?` for the generic type of `ResponseEntity`)

```java
// EmployeeResource.java
@DeleteMapping("/delete/{id}")
public ResponseEntity<?> deleteEmployee(@PathVariable("id") Long id) {
    employeeService.deleteEmployee(id);
    return new ResponseEntity<>(HttpStatus.OK);
}
```

<br/><br/>

Finally, now we can run this application and test those endpoints!

<br/>

Complete code for `src/main/java/.../employeemanager/EmployeeResource.java`:

```java
// Complete code for EmployeeResource.java
package com.radubulai.employeemanager;

import com.radubulai.employeemanager.model.Employee;
import com.radubulai.employeemanager.service.EmployeeService;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/employee")
public class EmployeeResource {
    private final EmployeeService employeeService;

    public EmployeeResource(EmployeeService employeeService) {
        this.employeeService = employeeService;
    }

    @GetMapping("/all")
    public ResponseEntity<List<Employee>> getAllEmployees() {
        List<Employee> employees = employeeService.findAllEmployees();
        return new ResponseEntity<>(employees, HttpStatus.OK);
    }

    @GetMapping("/find/{id}")
    public ResponseEntity<Employee> getEmployeeById(@PathVariable("id") Long id) {
        Employee employee = employeeService.findEmployeeById(id);
        return new ResponseEntity<>(employee, HttpStatus.OK);
    }

    @PostMapping("/add")
    public ResponseEntity<Employee> addEmployee(@RequestBody Employee employee) {
        Employee newEmployee = employeeService.addEmployee(employee);
        return new ResponseEntity<>(newEmployee, HttpStatus.CREATED);
    }

    @PutMapping("/update")
    public ResponseEntity<Employee> updateEmployee(@RequestBody Employee employee) {
        Employee updatedEmployee = employeeService.updateEmployee(employee);
        return new ResponseEntity<>(updatedEmployee, HttpStatus.OK);
    }

    @DeleteMapping("/delete/{id}")
    public ResponseEntity<?> deleteEmployee(@PathVariable("id") Long id) {
        employeeService.deleteEmployee(id);
        return new ResponseEntity<>(HttpStatus.OK);
    }
}
```

<br/>

## Testing with Postman

[Spring Boot Full Stack with Angular - Amigoscode - 0h50m: Testing](https://youtu.be/Gx4iBLKLVHk?t=3002)

You can download Postman from here: https://www.postman.com/downloads/ (Note as Monday, August 15, 2022, it might need an account in order to use Postman).

<br/>

Run the application (`mvn spring-boot:run` in terminal).

üü¢ Note that our Java Spring application runs on port `8080` by default (http://localhost:8080/). So we can already make a GET request to http://localhost:8080/employee/all with our browser (Chrome/Edge/Firefox/etc).

<br/>

In Postman, open a new tab... we should see our interface looking like this:

![](./SpringBootWithAngularCourse/Postman01.jpg)

<br/>

üîµ To send a GET request to http://localhost:8080/employee/all (`getAllEmployees`), we just need to add this URL here:

![](./SpringBootWithAngularCourse/Postman02.jpg)

Currently, our request will send us back a response with an empty list (because we don't have any employees/rows in our MySQL database).

<br/>

üîµ So, let's add some users/employees (`addEmployee`)!

- Open a new tab in Postman with the URL of http://localhost:8080/employee/add
- Set the request type to POST request
- Click on "Body" subtab, check the "raw" radio button, and select "JSON" format, and write a JSON like this (Note that the `id` will be generated by Spring JPA, and the `employeeCode` will be a random UUID generated string, so we don't need to pass those in):

```JSON
{
    "email": "alex@example.com",
    "imageUrl": "https://placekitten.com/200/300",
    "jobTitle": "Developer",
    "name": "Alex Craig",
    "phone": "4570090332"
}
```

or

```JSON
{
    "email": "andrew@example.com",
    "imageUrl": "https://placekitten.com/200/300",
    "jobTitle": "Developer",
    "name": "Andrew Johnson",
    "phone": "4570012342"
}
```

![](./SpringBootWithAngularCourse/Postman03.jpg)

We will receive back (as a response) our complete `Employee` object (as JSON), and this employee has now been added to the database as well (we can check with MySQL Workbench)! We can also see the request status code of `201 (created)`

![](./SpringBootWithAngularCourse/Postman04.jpg)

We can also see the rows from this `Employee` table (on `employeemanager` database) from the "MySQL 8.0 Command Line Client". We need to run these commands:

```SQL
show databases;
```

```SQL
use employeemanager;
```

```SQL
show tables;
```

```SQL
select * from employee;
```

![](./SpringBootWithAngularCourse/Postman05.jpg)

<br/>

Note that in our terminal (that is running our Spring Java App), we could also see the SQL queries that the application has sent (when receiving requests from Postman) to the MySQL database. That's because we have set `spring.jpa.show-sql=true` to true in our `application.properties` file.

```SQL
Hibernate: select employee0_.id as id1_0_, employee0_.email as email2_0_, employee0_.employee_code as employee3_0_, employee0_.image_url as image_ur4_0_, employee0_.job_title as job_titl5_0_, employee0_.name as name6_0_, employee0_.phone as phone7_0_ from employee employee0_

Hibernate: insert into employee (email, employee_code, image_url, job_title, name, phone) values (?, ?, ?, ?, ?, ?)
```

<br/>

üîµ Find one user by its Id (`getEmployeeById`) using Postman

- Open a new tab in Postman to the URL of http://localhost:8080/employee/find/2
- The request type will be GET

![](./SpringBootWithAngularCourse/Postman06.jpg)

<br/>

üîµ Let's update an employee (`updateEmployee`)!

- Open a new tab in Postman with the URL of http://localhost:8080/employee/update
- Set the request type to PUT request
- Click on "Body" subtab, check the "raw" radio button, and select "JSON" format
- Instead of this entry (that we currenly have in our database):

```JSON
{
    "id": 2,
    "name": "Andrew Johnson",
    "email": "andrew@example.com",
    "jobTitle": "Developer",
    "phone": "4570012342",
    "imageUrl": "https://placekitten.com/200/300",
    "employeeCode": "71703511-6ffe-4b29-8b00-bedd5c7c74b9"
}
```

- We'll send this (where the `name` and `imageUrl` was changed)

```JSON
{
    "id": 2,
    "name": "Andrew Merlin",
    "email": "andrew@example.com",
    "jobTitle": "Developer",
    "phone": "4570012342",
    "imageUrl": "https://placekitten.com/200/200",
    "employeeCode": "71703511-6ffe-4b29-8b00-bedd5c7c74b9"
}
```

- The information for that row (employee) was updated

![](./SpringBootWithAngularCourse/Postman07.jpg)


<br/>
<br/>

## Testing with HTTPie

[Spring Boot Full Stack with Angular - Amigoscode - 0h57m: Testing with HTTPie](https://youtu.be/Gx4iBLKLVHk?t=3446)

We can use [HTTPie](https://httpie.io/cli) to do the same tests that we did with Postman.

*This tutorial has skipped this part.*

Note that making request with HTTPie (CLI) instead of Postman (that has a GUI) is useful for applications that are stored in the cloud, so we can just SSH (or use [Putty](https://www.putty.org/)) into the PC/Server/Machine on cloud and start testing the API right there, on terminal.

We can also use [cURL](https://curl.se/) instead of HTTPie.

<br/>

# Front-End

[Spring Boot Full Stack with Angular - Amigoscode - 1h03m: Creating Angular App](https://youtu.be/Gx4iBLKLVHk?t=3815)

